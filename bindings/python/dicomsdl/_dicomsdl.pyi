from __future__ import annotations

import enum
from typing import Any, Callable, Optional, overload

DICOM_STANDARD_VERSION: str
DICOMSDL_VERSION: str
__version__: str
UID_PREFIX: str
IMPLEMENTATION_CLASS_UID: str
IMPLEMENTATION_VERSION_NAME: str

__all__ = [
    "LogLevel",
    "Reporter",
    "StderrReporter",
    "FileReporter",
    "BufferingReporter",
    "DICOM_STANDARD_VERSION",
    "DICOMSDL_VERSION",
    "__version__",
    "UID_PREFIX",
    "IMPLEMENTATION_CLASS_UID",
    "IMPLEMENTATION_VERSION_NAME",
    "log_info",
    "log_warn",
    "log_error",
    "set_default_reporter",
    "set_thread_reporter",
    "set_log_level",
    "DicomFile",
    "DataSet",
    "Tag",
    "VR",
    "Uid",
    "read_file",
    "read_bytes",
    "keyword_to_tag_vr",
    "tag_to_keyword",
    "tag_to_entry",
    "lookup_uid",
    "uid_from_value",
    "uid_from_keyword",
    "uid_prefix",
    "implementation_class_uid",
    "implementation_version_name",
    "is_valid_uid_text_strict",
    "make_uid_with_suffix",
    "try_append_uid",
    "append_uid",
    "try_generate_uid",
    "generate_uid",
    "generate_sop_instance_uid",
    "generate_series_instance_uid",
    "generate_study_instance_uid",
]


class LogLevel(enum.Enum):
    Info = ...
    Warning = ...
    Error = ...


class Reporter: ...


class StderrReporter(Reporter):
    def __init__(self) -> None: ...


class FileReporter(Reporter):
    def __init__(self, path: str) -> None: ...


class BufferingReporter(Reporter):
    def __init__(self, max_messages: int = ...) -> None: ...
    def take_messages(self, include_level: bool = ...) -> list[str]: ...
    def for_each(self, fn: Callable[[LogLevel, str], Any]) -> None: ...


def set_default_reporter(reporter: Reporter | None, /) -> None: ...
def set_thread_reporter(reporter: Reporter | None, /) -> None: ...
def set_log_level(level: LogLevel, /) -> None: ...
def log_info(message: str, /) -> None: ...
def log_warn(message: str, /) -> None: ...
def log_error(message: str, /) -> None: ...


class DicomFile:
    @property
    def path(self) -> str: ...

    @property
    def dataset(self) -> DataSet: ...

    @property
    def has_error(self) -> bool: ...

    @property
    def error_message(self) -> Optional[str]: ...

    def __len__(self) -> int: ...
    def __iter__(self) -> DataElementIterator: ...
    def __dir__(self) -> list[str]: ...
    def dump(self, max_print_chars: int = ..., include_offset: bool = ...) -> str: ...
    def rebuild_file_meta(self) -> None: ...
    def write_file(
        self,
        path: str,
        *,
        include_preamble: bool = ...,
        write_file_meta: bool = ...,
        keep_existing_meta: bool = ...,
    ) -> None: ...
    def write_bytes(
        self,
        *,
        include_preamble: bool = ...,
        write_file_meta: bool = ...,
        keep_existing_meta: bool = ...,
    ) -> bytes: ...
    def pixel_data(self, frame_index: int = ...) -> bytes: ...
    def to_array(
        self, frame: int = ..., scaled: bool = ..., htj2k_decoder: str = ...
    ) -> Any: ...
    def to_array_view(self, frame: int = ...) -> Any: ...
    def decode_into(
        self,
        out: Any,
        frame: int = ...,
        scaled: bool = ...,
        threads: int = ...,
        htj2k_decoder: str = ...,
    ) -> Any: ...
    def pixel_array(
        self, frame: int = ..., scaled: bool = ..., htj2k_decoder: str = ...
    ) -> Any: ...
    def to_pil_image(
        self,
        frame: int = ...,
        *,
        window: tuple[float, float] | None = ...,
        auto_window: bool = ...,
    ) -> Any: ...
    def __getitem__(self, key: Tag | int | str, /) -> Any: ...
    def __getattr__(self, name: str) -> Any: ...


class DataSet:
    def __init__(self) -> None: ...

    @property
    def path(self) -> str: ...

    def size(self) -> int: ...
    def dump(self, max_print_chars: int = ..., include_offset: bool = ...) -> str: ...
    def dump_elements(self) -> None: ...
    def add_dataelement(
        self, tag: Tag, vr: VR | None = ..., offset: int = ..., length: int = ...
    ) -> DataElement: ...
    def remove_dataelement(self, tag: Tag, /) -> None: ...
    @overload
    def get_dataelement(self, tag: Tag, /) -> DataElement: ...
    @overload
    def get_dataelement(self, packed_tag: int, /) -> DataElement: ...
    @overload
    def get_dataelement(self, tag_str: str, /) -> DataElement: ...
    def __getitem__(self, key: Tag | int | str, /) -> Any: ...
    def __getattr__(self, name: str) -> Any: ...
    def __dir__(self) -> list[str]: ...
    def __iter__(self) -> DataElementIterator: ...


class Sequence:
    def __len__(self) -> int: ...
    def __getitem__(self, index: int, /) -> DataSet: ...
    def __iter__(self) -> SequenceIterator: ...
    def add_dataset(self) -> DataSet: ...


class DataElement:
    @property
    def tag(self) -> Tag: ...

    @property
    def vr(self) -> VR: ...

    @property
    def length(self) -> int: ...

    @property
    def offset(self) -> int: ...

    @property
    def vm(self) -> int: ...

    @property
    def is_sequence(self) -> bool: ...

    @property
    def is_pixel_sequence(self) -> bool: ...

    @property
    def sequence(self) -> Optional[Sequence]: ...

    @property
    def pixel_sequence(self) -> Optional[PixelSequence]: ...

    def __bool__(self) -> bool: ...
    def is_present(self) -> bool: ...
    def is_missing(self) -> bool: ...

    def to_uid_string(self) -> Optional[str]: ...
    def to_string_view(self) -> Optional[str]: ...
    def to_string_views(self) -> Optional[list[str]]: ...
    def to_utf8_view(self) -> Optional[str]: ...
    def to_utf8_views(self) -> Optional[list[str]]: ...
    def to_transfer_syntax_uid(self) -> Optional[Uid]: ...
    def to_tag(self, default: Tag | None = ...) -> Optional[Tag]: ...
    def to_tag_vector(self) -> Optional[list[Tag]]: ...
    def to_int(self, default: int | None = ...) -> Optional[int]: ...
    def to_long(self, default: int | None = ...) -> Optional[int]: ...
    def to_longlong(self, default: int | None = ...) -> Optional[int]: ...
    def to_double(self, default: float | None = ...) -> Optional[float]: ...
    def to_int_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...
    def as_uint16_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...
    def as_uint8_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...
    def to_long_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...
    def to_longlong_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...
    def to_double_vector(self, default: list[float] | None = ...) -> Optional[list[float]]: ...
    def get_value(self) -> Any: ...
    def value_span(self) -> memoryview: ...


class DataElementIterator:
    def __iter__(self) -> DataElementIterator: ...
    def __next__(self) -> DataElement: ...


class SequenceIterator:
    def __iter__(self) -> SequenceIterator: ...
    def __next__(self) -> DataSet: ...


class PixelFragment:
    offset: int
    length: int


class PixelFrame:
    @property
    def encoded_size(self) -> int: ...
    @property
    def fragments(self) -> list[PixelFragment]: ...
    def encoded_bytes(self) -> bytes: ...
    def encoded_memoryview(self) -> memoryview: ...


class PixelSequence:
    @property
    def number_of_frames(self) -> int: ...
    @property
    def basic_offset_table_offset(self) -> int: ...
    @property
    def basic_offset_table_count(self) -> int: ...
    def __len__(self) -> int: ...
    def frame(self, index: int, /) -> PixelFrame: ...
    def frame_encoded_bytes(self, index: int, /) -> bytes: ...
    def frame_encoded_memoryview(self, index: int, /) -> memoryview: ...


class Tag:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, group: int, element: int, /) -> None: ...

    @overload
    def __init__(self, keyword: str, /) -> None: ...

    @staticmethod
    def from_value(value: int, /) -> Tag: ...

    @property
    def group(self) -> int: ...

    @property
    def element(self) -> int: ...

    @property
    def value(self) -> int: ...

    def is_private(self) -> bool: ...
    def __int__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __str__(self) -> str: ...


class VR:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, value: int, /) -> None: ...

    @staticmethod
    def from_string(value: str, /) -> VR: ...

    @staticmethod
    def from_chars(first: str, second: str, /) -> VR: ...

    @property
    def value(self) -> int: ...

    @property
    def is_known(self) -> bool: ...

    def is_string(self) -> bool: ...
    def is_binary(self) -> bool: ...
    def is_sequence(self) -> bool: ...
    def is_pixel_sequence(self) -> bool: ...
    def padding_byte(self) -> int: ...
    def uses_explicit_16bit_vl(self) -> bool: ...
    def fixed_length(self) -> int: ...
    def str(self) -> str: ...


def keyword_to_tag_vr(keyword: str, /) -> Optional[tuple[Tag, VR]]: ...


@overload
def tag_to_entry(tag: Tag, /) -> Optional[dict[str, Any]]: ...


@overload
def tag_to_entry(tag_value: int, /) -> Optional[dict[str, Any]]: ...


class Uid:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, text: str, /) -> None: ...

    @staticmethod
    def lookup(text: str, /) -> Optional[Uid]: ...

    @staticmethod
    def from_value(value: str, /) -> Uid: ...

    @staticmethod
    def from_keyword(keyword: str, /) -> Uid: ...

    @property
    def value(self) -> str: ...

    @property
    def keyword(self) -> Optional[str]: ...

    @property
    def name(self) -> str: ...

    @property
    def type(self) -> str: ...

    @property
    def raw_index(self) -> int: ...

    @property
    def is_valid(self) -> bool: ...

    def __bool__(self) -> bool: ...


def read_file(
    path: str,
    load_until: Tag | None = ...,
    keep_on_error: bool | None = ...,
) -> DicomFile: ...


def read_bytes(
    data: bytes | bytearray | memoryview,
    name: str = "<memory>",
    load_until: Tag | None = ...,
    keep_on_error: bool | None = ...,
    copy: bool = ...,
) -> DicomFile: ...


@overload
def tag_to_keyword(tag: Tag, /) -> Optional[str]: ...


@overload
def tag_to_keyword(tag_value: int, /) -> Optional[str]: ...


def lookup_uid(text: str, /) -> Optional[Uid]: ...
def uid_from_value(value: str, /) -> Uid: ...
def uid_from_keyword(keyword: str, /) -> Uid: ...
def uid_prefix() -> str: ...
def implementation_class_uid() -> str: ...
def implementation_version_name() -> str: ...
def is_valid_uid_text_strict(text: str, /) -> bool: ...
def make_uid_with_suffix(suffix: int, root: str | None = ..., /) -> Optional[str]: ...
def try_append_uid(base_uid: str, component: int, /) -> Optional[str]: ...
def append_uid(base_uid: str, component: int, /) -> str: ...
def try_generate_uid() -> Optional[str]: ...
def generate_uid() -> str: ...
def generate_sop_instance_uid() -> str: ...
def generate_series_instance_uid() -> str: ...
def generate_study_instance_uid() -> str: ...
