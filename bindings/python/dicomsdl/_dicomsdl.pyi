from __future__ import annotations

from typing import Any, Optional, overload

DICOM_STANDARD_VERSION: str
DICOMSDL_VERSION: str
__version__: str
UID_PREFIX: str
IMPLEMENTATION_CLASS_UID: str
IMPLEMENTATION_VERSION_NAME: str

__all__ = [
    "DICOM_STANDARD_VERSION",
    "DICOMSDL_VERSION",
    "__version__",
    "UID_PREFIX",
    "IMPLEMENTATION_CLASS_UID",
    "IMPLEMENTATION_VERSION_NAME",
    "DicomFile",
    "DataSet",
    "Sequence",
    "Tag",
    "Uid",
    "VR",
    "read_file",
    "read_bytes",
    "keyword_to_tag_vr",
    "tag_to_keyword",
    "tag_to_entry",
    "lookup_uid",
    "uid_from_value",
    "uid_from_keyword",
    "uid_prefix",
    "implementation_class_uid",
    "implementation_version_name",
    "is_valid_uid_text_strict",
    "make_uid_with_suffix",
    "try_append_uid",
    "append_uid",
    "try_generate_uid",
    "generate_uid",
    "generate_sop_instance_uid",
    "generate_series_instance_uid",
    "generate_study_instance_uid",
]

class DicomFile:
    @property
    def path(self) -> str: ...

    @property
    def dataset(self) -> DataSet: ...

    def __len__(self) -> int: ...
    def __iter__(self): ...
    def dump(self, max_print_chars: int = ..., include_offset: bool = ...) -> str: ...
    def rebuild_file_meta(self) -> None: ...
    def write_file(
        self,
        path: str,
        *,
        include_preamble: bool = ...,
        write_file_meta: bool = ...,
        keep_existing_meta: bool = ...,
    ) -> None: ...
    def write_bytes(
        self,
        *,
        include_preamble: bool = ...,
        write_file_meta: bool = ...,
        keep_existing_meta: bool = ...,
    ) -> bytes: ...
    def pixel_data(self, frame_index: int = ...) -> bytes: ...

    def to_array(
        self, frame: int = ..., scaled: bool = ..., htj2k_decoder: str = ...
    ) -> Any: ...

    def to_array_view(self, frame: int = ...) -> Any: ...

    def decode_into(
        self,
        out: Any,
        frame: int = ...,
        scaled: bool = ...,
        threads: int = ...,
        htj2k_decoder: str = ...,
    ) -> Any: ...

    def pixel_array(
        self, frame: int = ..., scaled: bool = ..., htj2k_decoder: str = ...
    ) -> Any: ...

    def __getitem__(self, key: Tag | int | str, /) -> Any: ...
    def __getattr__(self, name: str) -> Any: ...


class DataSet:
    @property
    def path(self) -> str: ...

    def size(self) -> int: ...
    def dump(self, max_print_chars: int = ..., include_offset: bool = ...) -> str: ...

    def to_pil_image(
        self,
        frame: int = ...,
        *,
        window: tuple[float, float] | None = ...,
        auto_window: bool = ...,
    ) -> Any: ...


class Sequence:
    def __len__(self) -> int: ...

    def __getitem__(self, index: int, /) -> DataSet: ...

    def __iter__(self): ...

    def add_dataset(self) -> DataSet: ...


class DataElement:
    @property
    def tag(self) -> Tag: ...

    @property
    def vr(self) -> VR: ...

    @property
    def length(self) -> int: ...

    @property
    def offset(self) -> int: ...

    @property
    def vm(self) -> int: ...

    @property
    def sequence(self) -> Optional[Sequence]: ...

    def to_tag(self, default: Tag | None = ...) -> Optional[Tag]: ...

    def to_tag_vector(self) -> Optional[list[Tag]]: ...

    def to_int(self, default: int | None = ...) -> Optional[int]: ...

    def to_long(self, default: int | None = ...) -> Optional[int]: ...

    def to_longlong(self, default: int | None = ...) -> Optional[int]: ...

    def to_double(self, default: float | None = ...) -> Optional[float]: ...

    def to_int_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...

    def as_uint16_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...

    def as_uint8_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...

    def to_long_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...

    def to_longlong_vector(self, default: list[int] | None = ...) -> Optional[list[int]]: ...

    def to_double_vector(self, default: list[float] | None = ...) -> Optional[list[float]]: ...

    def to_uid_string(self) -> Optional[str]: ...

    def to_string_view(self) -> Optional[str]: ...

    def to_string_views(self) -> Optional[list[str]]: ...

    def to_utf8_view(self) -> Optional[str]: ...

    def to_utf8_views(self) -> Optional[list[str]]: ...

    def to_transfer_syntax_uid(self) -> Optional[Uid]: ...


class Tag:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, group: int, element: int, /) -> None: ...

    @overload
    def __init__(self, keyword: str, /) -> None: ...

    @staticmethod
    def from_value(value: int, /) -> Tag: ...

    @property
    def group(self) -> int: ...

    @property
    def element(self) -> int: ...

    @property
    def value(self) -> int: ...

    def is_private(self) -> bool: ...

    def __int__(self) -> int: ...

    def __bool__(self) -> bool: ...


class VR:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, value: int, /) -> None: ...

    @staticmethod
    def from_string(value: str, /) -> VR: ...

    @staticmethod
    def from_chars(first: str, second: str, /) -> VR: ...

    @property
    def value(self) -> int: ...

    @property
    def is_known(self) -> bool: ...

    def is_string(self) -> bool: ...

    def is_binary(self) -> bool: ...

    def is_sequence(self) -> bool: ...

    def is_pixel_sequence(self) -> bool: ...

    def padding_byte(self) -> int: ...

    def uses_explicit_16bit_vl(self) -> bool: ...

    def fixed_length(self) -> int: ...

    def str(self) -> str: ...

    def first(self) -> str: ...

    def second(self) -> str: ...


def keyword_to_tag_vr(keyword: str, /) -> Optional[tuple[Tag, VR]]: ...

def tag_to_entry(tag: Tag | int, /) -> Optional[dict[str, Any]]: ...

class Uid:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, text: str, /) -> None: ...

    @staticmethod
    def lookup(text: str, /) -> Optional[Uid]: ...

    @staticmethod
    def from_value(value: str, /) -> Uid: ...

    @staticmethod
    def from_keyword(keyword: str, /) -> Uid: ...

    @property
    def value(self) -> str: ...

    @property
    def keyword(self) -> Optional[str]: ...

    @property
    def name(self) -> str: ...

    @property
    def type(self) -> str: ...

    @property
    def raw_index(self) -> int: ...

    @property
    def is_valid(self) -> bool: ...

    def __bool__(self) -> bool: ...


def read_file(path: str, /) -> DicomFile: ...


def read_bytes(data: bytes | bytearray | memoryview, name: str = "<memory>", /) -> DicomFile: ...


@overload
def tag_to_keyword(tag: Tag, /) -> Optional[str]: ...

@overload
def tag_to_keyword(tag_value: int, /) -> Optional[str]: ...

def lookup_uid(text: str, /) -> Optional[Uid]: ...

def uid_from_value(value: str, /) -> Uid: ...

def uid_from_keyword(keyword: str, /) -> Uid: ...

def uid_prefix() -> str: ...

def implementation_class_uid() -> str: ...

def implementation_version_name() -> str: ...

def is_valid_uid_text_strict(text: str, /) -> bool: ...

def make_uid_with_suffix(suffix: int, root: str | None = ..., /) -> Optional[str]: ...

def try_append_uid(base_uid: str, component: int, /) -> Optional[str]: ...

def append_uid(base_uid: str, component: int, /) -> str: ...

def try_generate_uid() -> Optional[str]: ...

def generate_uid() -> str: ...

def generate_sop_instance_uid() -> str: ...

def generate_series_instance_uid() -> str: ...

def generate_study_instance_uid() -> str: ...

# Logging helpers (mirrors C++ diag convenience)
def log_info(message: str, /) -> None: ...
def log_warn(message: str, /) -> None: ...
def log_error(message: str, /) -> None: ...
